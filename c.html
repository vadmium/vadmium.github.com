<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"
    "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
    <meta http-equiv=Content-Type content="text/html; charset=UTF-8">
    <title>C programming</title>
    <meta name="viewport" content="width=device-width">
</head>

<body>
<h1>C programming</h1>

<section id=trailing-commas>
<h2><a href="#trailing-commas">Trailing commas</a></h2>

<p>Initializer lists can have trailing commas even in C89.</p>

<p>Trailing commas are allowed in <i>enum</i> bodies since C99.</p>

<p>Trailing commas are not allowed in function call argument lists
(<a href="https://cigix.me/c23#6.5.3.1">C23 6.5.3.1</a>)</p>
</section>

<section id=storage><h2>
<a href="#storage">Storage-class specifies</a></h2>

<p>Storage-class specifiers should be at the beginning.
(<a href="https://cigix.me/c23#6.11.5.p1">C23 6.11.5 ¶1</a>)</p>
</section>

<section id=negative-division>
<h2><a href="#negative-division">Negative integer division and
remainder (modulo)</a></h2>

<p>In C99, signed integer division truncates towards zero.
If the result was negative and rounded up, the remainder is negative.
(<a href="https://port70.net/~nsz/c/c99/n1256.html#6.5.5">C99 6.5.5</a>)</p>
    <p>Before C99, division of negative integers can round
up or down (even when both operands are negative).
The remainder can be positive or negative. (<a
href="https://port70.net/~nsz/c/c89/c89-draft.html#3.3.5">C89 3.3.5</a>)</p>
</section>

<section id=data-types>
<h2><a href="#data-types">Data types</a></h2>

<section id=ints>
<h3><a href="#ints">Integers</a></h3>

<p>Unsigned integers consist of value bits and padding bits.
Incorrect values for padding bits may produce a trap representation.
When all value and padding bits are zero, this has to represent
the integer zero (not a trap representation).</p>
    <p>Every signed integer type has an unsigned counterpart, although
other unsigned types such as _Bool do not have to have a signed counterpart.
One bit in each unsigned type (either a value bit, or a padding bit)
corresponds to the sign bit. Every valid signed representation where
the sign bit is zero represents the same value in the unsigned type
(<a href="https://port70.net/~nsz/c/c99/n1256.html#6.2.6.2p5">C99
6.2.6.2 ¶5</a>). A signed integer may use two’s complement representation,
or before C23, sign-and-magnitude or one’s complement representation.
Before C23, the representation for negative zero, or the most negative value
in two’s complement, may be defined as a trap representation.
Before C23, the sign bit may be in addition to the value bits of the
unsigned counterpart, or the signed width may equal or be less than
the unsigned width. In C23, the widths must be equal, and the
most negative value is not a trap representation.</p>
    <p>The <i>unsigned char</i> type cannot have padding bits,
and an array of them can represent the bytes of any object.
C11 <i>signed char</i> has the same width, therefore does not have
any padding bits, but before C23 it may have a trap representation.
Plain <i>char</i> is a distinct type, but otherwise has the same
behaviour as either <i>signed</i> or <i>unsigned char</i>.</p>
    <p>The <i>uint</i>N<i>_t</i> types do not have padding bits;
therefore <i>N</i> must be a multiple of CHAR_BIT.
The <i>int</i>N<i>_t</i> types use two’s complement representation,
and cannot have padding bits nor a trap representation
(<a href="https://port70.net/~nsz/c/c99/n1256.html#7.18.2.1">C99
7.18.2.1</a>).</p>
    <p>Posix requires 8-bit <i>char</i>, so
(<i>u</i>)<i>int8_t</i>, and all (signed and unsigned) <i>char</i>
expressions are converted to <i>int</i> rather than <i>unsigned</i>.
</section>

<section id="pointers"><h3><a href="#pointers">Pointers</a></h3>

<p>Pointers to different types are not necessarily compatible, except that
a <i>void</i> pointer can hold a pointer to any type.</p>
    <p>C doesn’t require that a <i>void</i> pointer be able to store a
function pointer. Posix requires that function pointers returned from
<i>dlsym</i> can be stored in its <i>void</i> pointer return type. Before
the 2013 edition (TC1), it required all function pointers be convertible to
<i>void</i> pointers (changed in bug <a
href="http://austingroupbugs.net/view.php?id=74">74</a>).</p>
</section>

<section id=interchange>
<h3><a href="#interchange">Interchange</a></h3>

<p>The types in each of the following groups have the same size and
alignment, and the same representation for values that they support, and
may be interchanged in function arguments, return values, and unions.</p>

<ul>
    <li>Corresponding signed and unsigned integers</li>
    <li>Qualified (with <i>const</i>, <i>volatile</i>, and/or
        <i>restrict</i>) and unqualified types</li>
    <li>Pointers to <i>void</i> and (signed or unsigned) <i>char</i></li>
    <li>Pointers to qualified and unqualified versions of compatible
        types</li>
    <li>All pointers to structures</li>
    <li>All pointers to unions</li>
</ul>
</section>

</section>

<section id=bitwise>
<h2><a href="#bitwise">Bitwise operations</a></h2>

<p>Bitwise operations involving negative values depend on
the signed integer representation, and can produce trap values. This includes
negative operands, the bitwise complement of all signed values, and
the bitwise complement of shorter unsigned values that are promoted to
<i>signed int</i>. In general, it is better to use non-negative operands, and
only bitwise-complement unsigned operands of at least
<i>unsigned int</i> conversion rank.</p>
</section>

real floating-point to integer conversion truncates towards zero

<section id=printf>
<h2><a href="#printf"><i>printf</i></a></h2>

<p>A string conversion "%s" takes a pointer to a string of <i>char</i>.
If no precision is specified, the string must include a null byte.
If a precision is specified (e.g. "%.*s"), the C standard suggests
the string may not need to be null terminated
(<a href="https://port70.net/~nsz/c/c99/n1256.html#7.19.6.1p8">C99 7.19.6.1
¶8</a>).</p>
</section>

<section id=identifiers>
<h2><a href="#identifiers">Identifiers</a><h2>

<h3>&lt;fcntl.h&gt; (Posix)</h3>

<i>open</i>, O_*, SEEK_*, . . .

<h3>&lt;stdio.h&gt; (Posix)</h3>

FILE, (<i>s</i>)<i>size_t</i>, SEEK_*, EOF, NULL,
<i>stdin</i>, <i>stdout</i>, <i>stderr</i>,
<i>fopen</i>, . . .

<h3>&lt;unistd.h&gt; (Posix)</h3>

SEEK_*, NULL,
(<i>s</i>)<i>size_t</i>, <i>uid_t</i>, <i>gid_t</i>, <i>off_t</i>,
<i>pid_t</i>, <i>intptr_t</i>,
<i>close<i>, . . .
</section>

</body>
</html>
